#!/bin/sh /etc/rc.common

START=99
USE_PROCD=0

start_service() {
    logger -t realsync "start_service: 强制刷新UCI缓存"
    uci revert realsync
    config_load realsync
    logger -t realsync "start_service: 开始遍历任务"
    config_foreach start_task task
    logger -t realsync "start_service: 任务遍历结束"
}

start_task() {
    local section="$1"
    local enabled
    config_get enabled "$section" enabled
    logger -t realsync "start_task: section=$section enabled=$enabled"
    if [ "$enabled" = "1" ]; then
        logger -t realsync "start_task: section=$section 启动任务"
        # 检查是否已经在运行
        if pgrep -f "realsync.sh $section" >/dev/null; then
            logger -t realsync "start_task: section=$section 已在运行，跳过"
            return 0
        fi
        # 启动任务
        /usr/bin/realsync.sh "$section" &
        local pid=$!
        logger -t realsync "start_task: section=$section 启动成功，PID=$pid"
        # 保存PID到文件
        mkdir -p /var/run/realsync
        echo $pid > "/var/run/realsync/$section.pid"
    else
        logger -t realsync "start_task: section=$section 未启用，跳过"
    fi
}

reload_service() {
    logger -t realsync "reload_service: 重新加载服务"
    stop_service
    sleep 1
    start_service
}

stop_service() {
    logger -t realsync "stop_service: 开始停止所有 realsync 任务"
    
    # 方法1: 使用 killall 强制停止所有 realsync.sh 进程
    if command -v killall >/dev/null 2>&1; then
        logger -t realsync "stop_service: 使用 killall 停止进程"
        killall -9 realsync.sh 2>/dev/null
        sleep 0.5
    fi
    
    # 方法2: 使用 pkill 停止进程
    if command -v pkill >/dev/null 2>&1; then
        logger -t realsync "stop_service: 使用 pkill 停止进程"
        pkill -9 -f "realsync.sh" 2>/dev/null
        sleep 0.5
    fi
    
    # 方法3: 使用 pgrep + kill 停止进程（备用方案）
    local pids=$(pgrep -f "realsync.sh" 2>/dev/null)
    if [ -n "$pids" ]; then
        logger -t realsync "stop_service: 使用 pgrep + kill 停止进程: $pids"
        echo "$pids" | xargs kill -9 2>/dev/null
        sleep 0.5
    fi
    
    # 清理PID文件
    rm -f /var/run/realsync/*.pid 2>/dev/null
    
    # 最终检查是否还有进程残留
    local remaining=$(pgrep -f "realsync.sh" 2>/dev/null)
    if [ -n "$remaining" ]; then
        logger -t realsync "stop_service: 警告 - 仍有进程残留: $remaining"
    else
        logger -t realsync "stop_service: 所有进程已停止"
    fi
    
    return 0
}

print_all_sections() {
    config_load realsync
    local section
    for section in $(uci show realsync | grep "=task" | cut -d. -f2 | cut -d= -f1); do
        logger -t realsync "print_all_sections: section=$section"
    done
} 